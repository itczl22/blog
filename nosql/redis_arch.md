redis目前采用的是单进程单线程模型, 这里的单线程指的是处理请求的线程. 进程本身不完全是单线程, 还有若干后端线程主要做刷脏数据、关闭文件描述符等后台清理工作  

* redis中负责主要工作的是主线程, 主线程的工作包括但不限: 接收客户端连接、处理连接读写事件、解析请求、处理命令、处理定时器事件、数据同步等相关工作  

* 单进程单线程只能跑满一个CPU核, 对高并发的场景依然没法处理, 而常用的解决办法就是数据分片, 采用多server的分布式架构予以解决  

* 然而数据分片方式也存在若干问题：redis server过多难以管理、分片之后一些在单server上使用的命令无法支持、分片无法解决热点读写问题、分片后数据倾斜、数据重分布、数据扩缩容等也比较复杂  


__采用单线程的前提条件__

* 因为redis本身是操作内存的, 他的处理速度是非常快的. 对于高并发的请求其主要性能瓶颈在io, 即网络的处理速度, 并不是cpu. 但是得益于IO多路复用技术, 目前的单线程架构依然可以支撑redis的高并发, 单线程即使慢也满不了多少. 这是其可以采用单线程的前提

__采用单线程的根本原因__

* 多线程编程复杂度高, 可靠性降低, 对数据结构设计的约束大
  
* 并发读写时为了保证一致性就得需要加锁, 多线程模式在这个场景下并没有足够的吸引力

__单线程的优势__

* 单进程单线程代码编写简单，避免了多进程多线程的同步和通信问题

* 单线程不存在加锁的情况, 避免了加锁的开销

* 可以减少多进程多线程导致的上下文切换

__单线程的弊端__

* 现在的服务器基本都是多核cpu, 动辄就32核、64核的, 所以多线程根本不存在上下文切换的问题. Redis的单线程模型就是对这种昂贵的cpu的一种极大的浪费

* redis里遇到大key，这些查询操作也非常耗CPU，导致单线程响应非常不稳定, 因为它只能单线程处理完一个再处理另一个, 因此尽量避免长时间执行一个操作, 从而避免长时间阻塞在一个操作上

__多线程的改进__

* 随着时间的推移，单线程性能的问题也很多。多线程可以通过各种手段大大减少锁粒度，只是比较复杂。

* 因为读写网络的read/write系统调用在Redis执行期间占用了大部分CPU时间, 如果把网络读写做成多线程的方式对性能会有很大提升

* redis6.0加入了多线程(目前只有beta版本, 2020年4月左右会发布稳定版)

* redis 的多线程部分只是用来处理网络数据的读写和协议解析, 执行命令仍然是单线程. 之所以这么设计是不想 redis 因为多线程而变得复杂, 需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题, 而锁粒度处理不好性能反而可能会出现下降

