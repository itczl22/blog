redis的持久化(persistence)有两种方式: 快照rdb文件 和 追加aof文件

* rdb持久化方式会在一个特定的间隔保存那个时间点的一个数据快照, 每次都是全量的备份

* aof持久化方式则会记录每一个服务器收到的写操作. 在服务启动时这些记录的操作会逐条执行从而重建出原来的数据, 写操作命令记录的格式跟redis协议一致, 以追加的方式进行保存

* 两种方式的持久化是可以同时存在的, 但是当redis重启时, aof文件会被优先用于重建数据

* rdb并不是很可靠, 因为他是定时触发的, 一旦发生故障停机就可能会丢失期间的数据. 而aof文件则提供了一种更为可靠的持久化方式, 每当redis接受到会修改数据集的命令时就会把命令追加到AOF文件里, 当你重启redis时, aof里的命令会被重新执行一次重建数据. 但是aof的体积大于rdb, 且速度比rdb慢

__RDB__
* 优点

  * RDB 是一个非常紧凑的文件, 它保存了 redis 在某个时间点上的所有数据集. 这种文件非常适合用于进行备份: 比如可以在最近的 24小时内, 每小时备份一次 RDB 文件, 并且在每个月的每一天, 也备份一个 RDB 文件. 这样的话即使遇上问题也可以随时将数据集还原到不同的版本

  * RDB 可以最大化 redis 的性能: 父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程, 然后这个子进程就会处理接下来的所有保存工作, 父进程无须执行任何磁盘 I/O 操作

  * RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快

* 缺点

  * 如果你需要尽量避免在服务器故障时丢失数据, 那么 RDB 不适合. 因为RDB 文件需要保存整个数据集的状态, 所以它并不是一个轻松的操作, 因此你可能会至少 5 分钟才保存一次 RDB 文件, 在这种情况下一旦发生故障停机, 你就可能会丢失好几分钟的数据

  * 在数据集比较庞大时, fork 可能会非常耗时, 造成服务器在某某毫秒内停止处理客户端, 如果数据集非常巨大并且 CPU 时间非常紧张的话, 那么这种停止时间甚至可能会长达整整一秒. 虽然 AOF 重写也需要进行 fork, 但无论 AOF 重写的执行间隔有多长, 数据的耐久性都不会有任何损失

* 配置
  * save <seconds> <changes>
    会在指定秒数和数据变化次数之后把数据库写到磁盘上, save "" 表示关闭快照功能
    
  * stop-writes-on-bgsave-error no
    最新的bgsave失败, Redis不停止接受写操作
    
  * rdbcompression yes
    当导出到 .rdb 数据库时是否用LZF压缩字符串对象
    
  * rdbchecksum yes
    因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后, 这将使文件格式更加可靠, 但是会有cpu的开销
    
  * dbfilename dump.rdb
    持久化数据库的文件名

__AOF__
* 优点
  * 使用 AOF 持久化会让 Redis 变得非常耐久, 可以设置不同的 fsync 策略, 默认策略为每秒钟 fsync 一次. 在这种配置下, Redis 仍然可以保持良好的性能, 并且就算发生故障停机也最多只会丢失一秒钟的数据. fsync 会在后台线程执行, 所以主线程可以继续努力地处理命令请求
  
  * AOF 文件是一个只进行追加操作的日志文件(append only log) 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满、写入中途停机等等）redis-check-aof 工具也可以轻易地修复这种问题

  * Redis 可以在 AOF 文件体积变得过大时自动地在后台对 AOF 进行重写, 比如100次incr调整为set key 100. 整个重写操作是绝对安全的， 因为 Redis 在创建新 AOF 文件的过程中, 会继续将命令追加到现有的 AOF 文件里面, 即使重写过程中发生停机，现有的 AOF 文件也不会丢失. 而一旦新 AOF 文件创建完毕, Redis 就会从旧 AOF 文件切换到新 AOF 文件, 并开始对新 AOF 文件进行追加操作,

  * AOF 文件有序地保存了对数据库执行的所有写入操作, 这些写入操作以 Redis 协议的格式保存, 因此 AOF 文件的内容非常容易被人读懂. 导出 AOF 文件也非常简单, 比如你不小心执行了 FLUSHALL 命令, 但只要 AOF 文件未被重写, 那么只要停止服务器, 移除 AOF 文件末尾的 FLUSHALL 命令并重启 Redis 就可以将数据集恢复到 FLUSHALL 执行之前的状态
  
* 缺点

  * 对于相同的数据集来说, AOF 文件的体积通常要大于 RDB 文件的体积

  * 根据所使用的 fsync 策略, AOF 的速度可能会慢于 RDB. 在处理巨大的写入载入时, RDB 可以提供更有保证的最大延迟时间

* 配置
  * appendonly no 
    是否开启aof
  * appendfilename "appendonly.aof"
    aof文件名
  
  * appendfsync always/everysec/no
    fsync系统调用把数据写到磁盘上的时机

  * no-appendfsync-on-rewrite no
    在 BGSAVE 或 BGREWRITEAOF 处理时阻止主进程进行fsync()
  
  * auto-aof-rewrite-percentage 100 
    如果当前大小超过指定比例, 就会触发重写操作, 0表示禁用重写
    
  * auto-aof-rewrite-min-size 64mb
    日志的最小尺寸, 这样避免了达到指定百分比但尺寸仍然很小的情况还要重写
    
__AOF 和 RDB 的选择__

* 如果想达到足以媲美 PostgreSQL 的数据安全性, 应该同时使用两种持久化功能

* 如果可以承受数分钟以内的数据丢失, 那么可以只使用 RDB 持久化

* AOF 更安全, 可将数据及时同步到文件中, 但需要较多的磁盘IO, AOF文件尺寸较大, 文件内容恢复相对较慢

* RDB 是正常时期数据备份及 master-slave数据同步的最佳手段, 文件尺寸较小, 恢复数度较快

* 如果开启主从同步, 一般由slave做持久化, master关闭持久化


__参考__
* https://redis.io/topics/persistence
